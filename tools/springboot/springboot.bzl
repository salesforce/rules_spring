# Copyright (c) 2017, salesforce.com, inc.
# All rights reserved.
# Licensed under the BSD 3-Clause license.
# For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
#
# Spring Boot Packager
#
# See the macro documentation below for details.


# Spring Boot Executable JAR Layout specification
#   reverse engineered from the Spring Boot maven plugin

# /
# /META-INF/
# /META-INF/MANIFEST.MF                        <-- very specific manifest for Spring Boot (generated by this rule)
# /BOOT-INF
# /BOOT-INF/classes
# /BOOT-INF/classes/**/*.class                 <-- compiled application classes, must include @SpringBootApplication class
# /BOOT-INF/classes/META-INF/*                 <-- application level META-INF config files (e.g. spring.factories)
# /BOOT-INF/lib
# /BOOT-INF/lib/*.jar                          <-- all upstream transitive dependency jars must be here (except spring-boot-loader)
# /org/springframework/boot/loader
# /org/springframework/boot/loader/**/*.class  <-- the Spring Boot Loader classes must be here


# ***************************************************************
# Dependency Aggregator Rule
#  do not use directly, see the SpringBoot Macro below

def _depaggregator_rule_impl(ctx):
  # magical incantation for getting upstream transitive closure of java deps
  merged = java_common.merge([dep[java_common.provider] for dep in ctx.attr.deps])
  jars = merged.transitive_runtime_jars

  #print("AGGREGATED DEPS")
  #print(jars)

  return [DefaultInfo(files=jars)]

_depaggregator_rule = rule(
    implementation=_depaggregator_rule_impl,
    attrs={
        "depaggregator_rule": attr.label(),
        "deps": attr.label_list(providers=[java_common.provider]),
    },
)

# ***************************************************************
# SpringBoot Rule
#  do not use directly, see the SpringBoot Macro below

def _springboot_rule_impl(ctx):
  outs = depset()
  outs += ctx.attr.app_compile_rule.files
  outs += ctx.attr.genmanifest_rule.files
  outs += ctx.attr.genjar_rule.files

  merged = java_common.merge([dep[java_common.provider] for dep in ctx.attr.deps])
  jars = merged.transitive_runtime_jars
  #print("TRANSITIVE DEPS")
  #print(jars)

  return [DefaultInfo(files=outs)]

_springboot_rule = rule(
    implementation=_springboot_rule_impl,
    attrs={
        "app_compile_rule": attr.label(),
        "dep_aggregator_rule": attr.label(),
        "genmanifest_rule": attr.label(),
        "genjar_rule": attr.label(),
        "deps": attr.label_list(providers=[java_common.provider]),
    },
)

# ***************************************************************
# SpringBoot Macro
#  invoke this from your BUILD file
#
#  name:    name of your application
#  boot_app_class:  the classname (java package+type) of the @SpringBootApplication class in your app
#  deps:  the array of upstream dependencies
#  resources (optional): list of resources to build into the jar, if not specified, assumes src/main/resources/**/*

def springboot(name, boot_app_class, deps, resources=[]):
  # Create the subrule names
  appcompile_rule = native.package_name() + "_app"
  dep_aggregator_rule = native.package_name() + "_deps"
  genmanifest_rule = native.package_name() + "_genmanifest"
  genjar_rule = native.package_name() + "_genjar"

  # Append to the passed deps with the standard Spring Boot deps as a convenience
  _add_default_deps(deps)

  # for resources, assume all files in the standard location unless overridden by config
  if len(resources) == 0:
    resources = native.glob(["src/main/resources/**/*"])

  # SUBRULE 1: COMPILE THE SPRING BOOT APPLICATION
  # Note that we dont allow non-standard source file locations to keep things simple
  native.java_binary(
      name = appcompile_rule,
      srcs = native.glob(["src/main/java/**/*.java"]),
      resources = resources,
      main_class = boot_app_class,
      deps = deps,
  )

  # SUBRULE 2: AGGREGATE UPSTREAM DEPS
  #  Aggregate transitive closure of upstream Java deps
  _depaggregator_rule(
     name = dep_aggregator_rule,
     deps = deps,
  )

  # SUBRULE 3: GENERATE THE MANIFEST
  #  NICER: derive the Build JDK and Boot Version values by scanning transitive deps
  genmanifest_cmd = "echo 'Manifest-Version: 1.0' >$@;"\
      + "echo 'Created-By: Bazel' >>$@;"\
      + "echo 'Built-By: Bazel' >>$@;"\
      + "echo 'Throw-Down: hootenanny' >>$@;"\
      + "echo 'Main-Class: org.springframework.boot.loader.JarLauncher' >>$@;"\
      + "echo 'Spring-Boot-Classes: BOOT-INF/classes/' >>$@;"\
      + "echo 'Spring-Boot-Lib: BOOT-INF/lib/' >>$@;"\
      + "echo 'Spring-Boot-Version: 1.5.6.RELEASE' >>$@;"\
      + "echo 'Build-Jdk: 1.8.0_40' >>$@;"\
      + "echo 'Start-Class: " + boot_app_class + "' >>$@;"
  genmanifest_out = "MANIFEST.MF"
  native.genrule(
      name = genmanifest_rule,
      cmd = genmanifest_cmd,
      message = "SpringBoot rule is writing the MANIFEST.MF...",
      outs = [genmanifest_out]
  )

  # SUBRULE 4: INVOKE THE BASH SCRIPT THAT DOES THE PACKAGING
  # The resolved input_file_paths array is made available as the $(SRCS) token in the cmd string.
  # Skylark will convert the logical input_file_paths into real file system paths when surfaced in $(SRCS)
  #  cmd format (see springboot_pkg.sh)
  #    param1: boot application classname (the @SpringBootApplication class)
  #    param2: executable jar output filename to write to
  #    param3: compiled application jar
  #    param4: manifest file
  #    paramN: upstream transitive dependency jar(s)
  native.genrule(
      name = genjar_rule,
      srcs = [":"+appcompile_rule, ":"+genmanifest_rule, ":"+dep_aggregator_rule],
      cmd = "$(location //tools/springboot:springboot_pkg.sh) "+boot_app_class+" $@ $(SRCS)",
      tools = ["//tools/springboot:springboot_pkg.sh"],
      outs = [name + "_springboot.jar"],
  )

  # MASTER RULE: Create the composite rule that will aggregate the outputs of the subrules
  _springboot_rule(
      name = name,
      app_compile_rule = ":" + appcompile_rule,
      dep_aggregator_rule = ":" + dep_aggregator_rule,
      genmanifest_rule = ":" + genmanifest_rule,
      genjar_rule = ":" + genjar_rule,
      deps = deps,
  )
# end springboot macro


# ***************************************************************
# Dependency Management
#
# Some convenience macros for adding Boot starters, and default Boot dependencies.

# Starters

def add_boot_jetty_starter(deps):
  _safe_add(deps, "@org_springframework_boot_spring_boot_starter_jetty//jar")
  _safe_add(deps, "@org_springframework_boot_spring_boot_starter_jetty//jar")
  _safe_add(deps, "@org_eclipse_jetty_jetty_server//jar")
  _safe_add(deps, "@org_eclipse_jetty_jetty_servlet//jar")
  _safe_add(deps, "@org_eclipse_jetty_jetty_util//jar")
  _safe_add(deps, "@org_eclipse_jetty_jetty_webapp//jar")
  _safe_add(deps, "@org_eclipse_jetty_jetty_security//jar")
  _safe_add(deps, "@org_eclipse_jetty_jetty_http//jar")
  _safe_add(deps, "@org_eclipse_jetty_jetty_io//jar")

def add_boot_web_starter(deps):
  _safe_add(deps, "@org_springframework_boot_spring_boot_starter_web//jar")

def add_boot_actuator_starter(deps):
    _safe_add(deps, "@org_springframework_boot_spring_boot_starter_actuator//jar")
    _safe_add(deps, "@org_springframework_boot_spring_boot_actuator//jar")
    _safe_add(deps, "@com_fasterxml_jackson_core_jackson_databind//jar")
    _safe_add(deps, "@com_fasterxml_jackson_core_jackson_core//jar")
    _safe_add(deps, "@com_fasterxml_jackson_core_jackson_annotations//jar")


# Default Dependencies

# Add in the standard Spring Boot dependencies so that app devs don't
# need to explicitly state them every time in the BUILD file.
def _add_default_deps(deps):
  _safe_add(deps, "@javax_servlet_javax_servlet_api//jar")

  _safe_add(deps, "@org_springframework_spring_beans//jar")
  _safe_add(deps, "@org_springframework_spring_context//jar")
  _safe_add(deps, "@org_springframework_spring_web//jar")
  _safe_add(deps, "@org_springframework_spring_core//jar")
  _safe_add(deps, "@org_springframework_spring_aop//jar")
  _safe_add(deps, "@org_springframework_spring_expression//jar")

  _safe_add(deps, "@org_springframework_boot_spring_boot//jar")
  _safe_add(deps, "@org_springframework_boot_spring_boot_autoconfigure//jar")
  _safe_add(deps, "@org_springframework_boot_spring_boot_loader//jar")
  _safe_add(deps, "@org_springframework_boot_spring_boot_starter//jar")
  _safe_add(deps, "@org_springframework_boot_spring_boot_starter_logging//jar")


# Bazel will fail if a dependency appears twice for the same target, so be safe when
# adding a dependencies to the deps list
def _safe_add(deps, dep):
  if not (dep in deps):
    deps.append(dep)
